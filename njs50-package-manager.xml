<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>check for updates</name>
			<script>expandAlias('njs50pm status')</script>
			<command></command>
			<packageName></packageName>
			<time>00:20:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>auto update packages</name>
			<script>expandAlias('njs50pm update')</script>
			<command></command>
			<packageName></packageName>
			<time>12:00:00.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm</name>
			<script>cecho('\n&lt;green&gt;njs50pm:&lt;white&gt; commands\n')

cecho('&lt;white&gt;njs50pm help&lt;reset&gt;              - View the contents of this help file\n')

cecho('&lt;white&gt;njs50pm list&lt;reset&gt;              - List packages available to install\n')

cecho('&lt;white&gt;njs50pm install &lt;package&gt;&lt;reset&gt; - Show status of installed packages\n')

cecho('&lt;white&gt;njs50pm update&lt;reset&gt;            - Update any installed packages if possible\n')

cecho('&lt;white&gt;njs50pm update &lt;package&gt;&lt;reset&gt;  - Update a specific package if possible\n')

cecho('&lt;white&gt;njs50pm status&lt;reset&gt;            - Show status of installed packages\n')

cecho('\n')
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(njs50pm|njs50pm help)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm list</name>
			<script>-- cecho('\n\n&lt;green&gt;njs50pm:&lt;white&gt; available packages...\n')
njs50pm.list()</script>
			<command></command>
			<packageName></packageName>
			<regex>^njs50pm list$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm install</name>
			<script>local pkg = matches[2]
cecho('\n\n&lt;green&gt;njs50pm:&lt;white&gt; installing package : ' .. pkg .. '\n')

njs50pm.install(pkg)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^njs50pm install (.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm update</name>
			<script>cecho('\n\n&lt;green&gt;njs50pm:&lt;white&gt; updating packages...\n')
njs50pm.updateAll()</script>
			<command></command>
			<packageName></packageName>
			<regex>^njs50pm update$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm update specific</name>
			<script>local pkg = matches[2]
cecho('\n\n&lt;green&gt;njs50pm:&lt;white&gt; updating package : ' .. pkg .. '\n')

-- clear the cache if we are trying to upgrade a specific package
njs50pm.clearCache(pkg)
njs50pm.upgradeIfAvailable(pkg)

-- njs50pm.updateAll()</script>
			<command></command>
			<packageName></packageName>
			<regex>^njs50pm update (.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm uninstall</name>
			<script>local pkg = matches[2]
cecho('\n\n&lt;green&gt;njs50pm:&lt;white&gt; uninstalling package : ' .. pkg .. '\n')

njs50pm.uninstall(pkg)

-- njs50pm.updateAll()</script>
			<command></command>
			<packageName></packageName>
			<regex>^njs50pm uninstall (.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>njs50pm status</name>
			<script>cecho('\n\n&lt;green&gt;njs50pm:&lt;white&gt; installed package status...\n')
njs50pm.showStatus()</script>
			<command></command>
			<packageName></packageName>
			<regex>^njs50pm status$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>njs50pm</name>
			<packageName></packageName>
			<script>-- exmaples:

-- install tfecat / my mapper
-- lua njs50pm.install({module = 'tfecat', githubPath = '/mudlet/tfecat.module'})
-- lua njs50pm.install({module = 'tfe-mapper'})

-- modify a packages metadata to make it look like it needs an update
-- lua setPackageInfo('tfecat', "njs50-hash", 'bannana')

-- check all installed modules status
-- lua njs50pm.showStatus()

-- get all available updates
-- lua njs50pm.updateAll()

-- update a single module if there is an update
-- lua njs50pm.upgradeIfAvailable('tfecat')


njs50pm = njs50pm or {}

-- until the mudlet functions persist...
njs50pm.setPackageInfo = function(package, variable, value)
  
  if not njs50pm.packageInfo then
    njs50pm.packageInfo = {}
    if io.exists(getMudletHomeDir().."/njs50PackageInfo.lua") then
      table.load(getMudletHomeDir().."/njs50PackageInfo.lua", njs50pm.packageInfo)
    end
  end

  -- -- set the packageInfo anyway?
  -- setPackageInfo(package, variable, value)
  
  njs50pm.packageInfo[package] = njs50pm.packageInfo[package] or {}
  
  if (value == '') then
    value = nil
  end
  
  njs50pm.packageInfo[package][variable] = value
  
  table.save(getMudletHomeDir().."/njs50PackageInfo.lua", njs50pm.packageInfo)
  
end

njs50pm.getPackageInfo = function(package, variable)

  if not njs50pm.packageInfo then
    njs50pm.packageInfo = {}
    if io.exists(getMudletHomeDir().."/njs50PackageInfo.lua") then
      table.load(getMudletHomeDir().."/njs50PackageInfo.lua", njs50pm.packageInfo)
    end
  end
  
  local vp = njs50pm.packageInfo[package] or {}
  local value = vp[variable]
  
  if not value then 
    value = "" 
  end
  
  return value
  
end

      
njs50pm.log = function(pkg, msg) 
  cecho('\n&lt;green&gt;njs50pm: &lt;white&gt;' .. pkg .. ' package ' .. msg .. '!\n') 
end

njs50pm.isInstalled = function(package)
  return table.contains(getPackages(), package)
end



njs50pm.getStatus = function(callback)

  -- make sure all installed packages have the correct metadata
  njs50pm.checkPackageMetadata()

  local co
  local installed = {}

  co = coroutine.create(function()

    for idx, mod in ipairs(getPackages()) do
    
      local package = njs50pm.getLocalMetadata(mod)
    
      if package.hash ~= '' then
        
        package.callback = function(hash)
          table.insert(installed, { 
            name = mod, 
            metadata = package, 
            remoteHash = hash
          })
          local ok, errorMsg = coroutine.resume(co)
          if not ok then
            error("Error in co-routine njs50pm: " .. errorMsg)
          end
        end
        
        njs50pm.getRemoteHash(package)
        coroutine.yield()
                
      end
      
    end     
  
    callback(installed)   
  
  end)

  local ok, errorMsg = coroutine.resume(co)
  if not ok then
    error("Error in co-routine njs50pm: " .. errorMsg)
  end

end


njs50pm.showStatus = function()

  njs50pm.getStatus(function(installed)
    
    if (#installed &gt; 0) then
      for idx, package in ipairs(installed) do
        cecho('&lt;white&gt;' .. package.name .. ' : ')
        if (package.remoteHash == package.metadata.hash) then
          cecho('&lt;green&gt;latest version: &lt;white&gt;' .. package.metadata.hash .. '\n')
        else
          cecho('&lt;orange&gt;update available: &lt;white&gt;' .. package.remoteHash .. ' from ' .. package.metadata.hash .. '\n')
        end
      end
    else
      cecho('\n&lt;green&gt;njs50pm:&lt;white&gt; no packages installed\n\n')
    end

  end)

end


njs50pm.updateAll = function()

  njs50pm.getStatus(function(installed)
    
    local co
  
    co = coroutine.create(function()    
    
        if (#installed &gt; 0) then
          for idx, package in ipairs(installed) do
            cecho('&lt;white&gt;' .. package.name .. ' : ')
            if (package.remoteHash == package.metadata.hash) then
              cecho('&lt;green&gt;latest version\n')
            else
              cecho('&lt;orange&gt;updating\n')
              njs50pm.upgradeIfAvailable(package.name, function()
                local ok, errorMsg = coroutine.resume(co)
                if not ok then
                error("Error in upgrade co-routine njs50pm: " .. errorMsg)
              end
              end)
              coroutine.yield()
            end
          end
        else
          cecho('\n&lt;green&gt;njs50pm:&lt;white&gt; no packages installed\n\n')
        end
        
    end) -- end coroutine

    local ok, errorMsg = coroutine.resume(co)
    if not ok then
      error("Error in co-routine njs50pm: " .. errorMsg)
    end

  end)

end


njs50pm.upgradeIfAvailable = function(mod, cb)
  
  if not mod or mod == '' then
    cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; module is a required option\n\n')
    return
  end
  
  local options = njs50pm.getLocalMetadata(mod)

  if (options.module == '') then
     cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; package not found (' .. mod .. ') \n\n')
    return 
  end
  
  options.callback = cb

  njs50pm.isUpdateAvailable({
    module = options.module,
    githubUser = options.githubUser,
    branch = options.branch,
    callback = function(bUpdateAvailable) 
      
      if (bUpdateAvailable) then
        cecho('\n&lt;yellow&gt;njs50pm:&lt;white&gt; ' .. options.module .. ' has an update available!\n')
        njs50pm.install(options)
      else
        cecho('\n&lt;green&gt;njs50pm:&lt;white&gt; ' .. options.module .. ' is up to date!\n')
        if (cb) then cb() end
      end
          
    end
  })
  
end


njs50pm.isUpdateAvailable = function(options)
  
  if not options or type(options) ~= 'table' or not options.module then
    cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; module is a required option\n\n')
    return
  end
  
  options.githubUser = options.githubUser or 'njs50'
  options.branch = options.branch or 'main'
  options.callback = options.callback or display
  
  local currentHash = njs50pm.getPackageInfo(options.module, 'njs50-hash')
  
  njs50pm.getRemoteHash({
    module = options.module,
    githubUser = options.githubUser,
    branch = options.branch,
    callback = function(hash)
      options.callback(hash ~= currentHash)
    end,
  })  
  
end

njs50pm.uninstall = function(package)
  if (njs50pm.isInstalled(package)) then
    njs50pm.setPackageInfo(package, "njs50-module", '')    
    njs50pm.setPackageInfo(package, "njs50-hash", '')
    njs50pm.setPackageInfo(package, "njs50-branch", '')
    njs50pm.setPackageInfo(package, "njs50-githubUser", '')
    njs50pm.setPackageInfo(package, "njs50-githubPath", '')
    uninstallPackage(package)
    njs50pm.log(package, 'uninstalled')
  else
    njs50pm.log(package, 'was not installed')
  end
end

njs50pm.install = function (options)
  
  if type(options) == 'string' then
    
    if (options ~= '' and njs50pm.packages[options]) then
      options = njs50pm.packages[options]
    else
      cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; unknown package: ' .. options .. '\n\n')
      return
    end
  end  
  
  
  if not options or type(options) ~= 'table' or not options.module then
    cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; a package is a required \n\n')
    return
  end
  
  if table.contains(getModules(), options.module) then
    cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; this package is already installed as a module!\n\n')
    return  
  end
  
  options.githubUser = options.githubUser or 'njs50'
  options.branch = options.branch or 'main'
  options.callback = options.callback or function() end
  options.githubPath = options.githubPath or ''
  
  njs50pm.getRemoteHash({
    module = options.module,
    githubUser = options.githubUser,
    branch = options.branch,
    callback = function(hash)

      -- njs50/tfecat/fb20eb10f6c0e0bf40354b62a0a3a752642075e6/mudlet/tfecat.module/tfecat.xml  
      local URL = 'https://raw.githubusercontent.com/' .. options.githubUser .. 
        '/' .. options.module .. '/' .. hash .. options.githubPath .. 
        '/' .. options.module .. '.xml'
      
      local installHandler
    
      installHandler = registerAnonymousEventHandler("sysInstallPackage", function(_, name)
        -- stop if what got installed isn't my thing
        if name ~= options.module then 
          return 
        end
        
        killAnonymousEventHandler(installHandler)
            
        njs50pm.setPackageInfo(options.module, "njs50-module", options.module)    
        njs50pm.setPackageInfo(options.module, "njs50-hash", hash)
        njs50pm.setPackageInfo(options.module, "njs50-branch", options.branch)
        njs50pm.setPackageInfo(options.module, "njs50-githubUser", options.githubUser)
        njs50pm.setPackageInfo(options.module, "njs50-githubPath", options.githubPath)
        
        njs50pm.log(options.module, 'installed')
        raiseEvent('COMMON:njs50-module-updated-' .. options.module)
        options.callback()
        
      end)
      
      if (njs50pm.isInstalled(options.module)) then
        uninstallPackage(options.module)
        njs50pm.log(options.module, 'uninstalled')
      
        tempTimer(0.25, function()
          installPackage(URL)
        end)
      
      else  
        installPackage(URL)
      end      
      
    end
  })
  
end

njs50pm.getLocalMetadata = function(mod) 
  return {
    ['module'] = njs50pm.getPackageInfo(mod, "njs50-module"),
    hash = njs50pm.getPackageInfo(mod, "njs50-hash"),
    branch = njs50pm.getPackageInfo(mod, "njs50-branch"),
    githubUser = njs50pm.getPackageInfo(mod, "njs50-githubUser"),
    githubPath = njs50pm.getPackageInfo(mod, "njs50-githubPath"),    
  }
end

-- options are:
--   module (required) i.e tfecat
--
--   branch (optional, defaults to main)
--   

njs50pm.checkRateLimit = function()

-- 
  local url = "https://api.github.com/rate_limit"
  local header = {["Content-Type"] = "application/json"}
  local responseHandler, errorHandler
  
  local selfDestruct = function()
    killAnonymousEventHandler(responseHandler)
    killAnonymousEventHandler(errorHandler)
  end
  
  -- first we create something to handle the success, and tell us what we got
  responseHandler = registerAnonymousEventHandler('sysGetHttpDone', function(event, rurl, response)
    if rurl == url then 
      selfDestruct()
      
      response = yajl.to_value(response)
      
      if (response.rate.remaining == 0) then
        -- cecho('\n&lt;orange&gt;GITHUB:&lt;white&gt; API unlocks in ' .. common.formatElapsedTime((response.rate.reset) - getEpoch()) .. '\n')
        cecho('\n&lt;orange&gt;GITHUB:&lt;white&gt; API unlocks in ' .. tostring((response.rate.reset) - getEpoch()) .. 's\n')
      else
        cecho('\n&lt;green&gt;GITHUB:&lt;white&gt; ' .. tostring(response.rate.remaining) .. ' API requests remaining\n')
      end
      
    end
    
  end)
  
  -- then we create something to handle the error message, and tell us what went wrong
  errorHandler = registerAnonymousEventHandler('sysGetHttpError', function(event, response, rurl)
    if rurl == url then 
      selfDestruct()
      
      cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; failed to retrieve rate limit data from github\n\n')
      display(response) 
      
    end
  end)
  
  -- Lastly, we make the request:
  getHTTP(url, header)  
  
end


njs50pm.hashCache = njs50pm.hashCache or {}

njs50pm.clearCache = function(module)
  if not module or module == '' then
    njs50pm.hashCache = {}
  else
    njs50pm.hashCache[module] = nil
  end
end

njs50pm.cacheTime = 20 * 60 -- 20 minutes

njs50pm.cacheRequest = function(module, response)
  njs50pm.hashCache[module] = {
    data = response,
    dt = getEpoch()
  }
end

njs50pm.getCachedRequest = function(module)
  local cr = njs50pm.hashCache[module]
  if (cr and getEpoch() - cr.dt &lt; njs50pm.cacheTime) then
    cecho('\n&lt;green&gt;njs50pm:&lt;white&gt; loaded ' .. module .. ' hash from cache\n')
    -- display(cr.data)
    return cr.data
  end
  return nil
end

njs50pm.getRemoteHash = function(options)
  
  if not options or type(options) ~= 'table' or not options.module then
    cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; module is a required option\n\n')
    return
  end
  
  options.githubUser = options.githubUser or 'njs50'
  options.branch = options.branch or 'main'
  options.callback = options.callback or display
  
  local url = "https://api.github.com/repos/" .. options.githubUser .. "/" .. options.module .. "/branches"
  local header = {["Content-Type"] = "application/json"}
  
  
  local cachedRequest = njs50pm.getCachedRequest(options.module)
  
  if (cachedRequest) then
    -- because of coroutine this needs to happen outside this execution
    tempTimer(0, function()
      options.callback(cachedRequest)
    end)
    return 
  end
  
  
  
  local responseHandler, errorHandler
  
  local selfDestruct = function()
    killAnonymousEventHandler(responseHandler)
    killAnonymousEventHandler(errorHandler)
  end
  
  -- first we create something to handle the success, and tell us what we got
  responseHandler = registerAnonymousEventHandler('sysGetHttpDone', function(event, rurl, response)
    if rurl == url then 
      selfDestruct()
      
      response = yajl.to_value(response)
      
      for idx, branch in ipairs(response) do
        if (branch.name == options.branch) then
          njs50pm.cacheRequest(options.module, branch.commit.sha)
          return options.callback(branch.commit.sha)
        end 
      end 
      
      cecho('\n&lt;orange&gt;njs50pm:&lt;white&gt; module or branch not found\n\n')
      
    end
    
  end)
  
  -- then we create something to handle the error message, and tell us what went wrong
  errorHandler = registerAnonymousEventHandler('sysGetHttpError', function(event, response, rurl)
    if rurl == url then 
      selfDestruct()
      
      cecho('\n&lt;red&gt;njs50pm:&lt;white&gt; failed to retrieve versions from github\n\n')
      display(response) 
      njs50pm.checkRateLimit()
      
    end
  end)
  
  -- Lastly, we make the request:
  getHTTP(url, header)

end

njs50pm.checkPackageMetadata = function()
  
  local installed = getPackages()
  -- njs50pm.packages
  
  for idx, package in ipairs(installed) do
    if (njs50pm.packages[package]) then

      local pdata = njs50pm.packages[package]
      local md = njs50pm.getLocalMetadata(package)
      
      if (md.module == '') then
        njs50pm.log(package, 'updating metadata')
        njs50pm.setPackageInfo(package, "njs50-module", package)    
        njs50pm.setPackageInfo(package, "njs50-hash", 'forcing-an-update')
        njs50pm.setPackageInfo(package, "njs50-branch", pdata.branch)
        njs50pm.setPackageInfo(package, "njs50-githubUser", pdata.githubUser)
        njs50pm.setPackageInfo(package, "njs50-githubPath", pdata.githubPath)      
      end
      
      
    end
  end
  
  -- 
 
  -- if md.module == '' then

  -- end
  
  
end



njs50pm.setupTestUpdate = function()

  njs50pm.setPackageInfo('tfecat', "njs50-hash", 'forcing-an-update')
  njs50pm.setPackageInfo('tfe-mapper', "njs50-hash", 'forcing-an-update')
  njs50pm.setPackageInfo('njs50-tfe', "njs50-hash", 'forcing-an-update')
 
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>njs50pm: package registry</name>
			<packageName></packageName>
			<script>njs50pm = njs50pm or {}

njs50pm.packages = njs50pm.packages or {}
  
njs50pm.packages["tfecat"] = { 
  name = 'tfecat',
  description = 'better than the tfecat website, and in game!',
  module = 'tfecat', 
  branch = 'master',
  githubPath = '/mudlet/tfecat.module',
  githubUser = 'njs50',
}

njs50pm.packages["tfe-mapper"] = { 
  name = 'tfe-mapper',
  description = 'a mapper for tfe by njs50',
  module = 'tfe-mapper', 
  branch = 'master',
  githubPath = '',
  githubUser = 'njs50',
}

njs50pm.packages["njs50-tfe"] = { 
  name = 'njs50-tfe',
  description = 'a dump of my personal code, probably unusable',
  module = 'njs50-tfe', 
  branch = 'main',
  githubPath = '',
  githubUser = 'njs50',
}

njs50pm.packages["njs50-package-manager"] = { 
  name = 'njs50-package-manager',
  description = 'this package manager!',
  module = 'njs50-package-manager', 
  branch = 'main',
  githubPath = '',
  githubUser = 'njs50',
}


njs50pm.list = function()
  
  local st = demonnic.TableMaker:new({
    edgeCharacter = '|'
  })
    
  st:addColumn({name = "Package", width = 25, textColor = "&lt;green&gt;"})
  st:addColumn({name = "Description", width = 52, textColor = "&lt;white&gt;", ["alignment"] = "left"})

  for pname, pdata in pairs(njs50pm.packages) do
  
    st:addRow({pname, ' ' .. pdata.description})
  end
  
  cecho(st:assemble())

  
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>demonnic</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>--- fText processing
-- @module demonnic
demonnic = demonnic or {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then
    error("Improper argument: options expected to be passed as table")
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
  options.rightCap = options.cap
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then
      gapSpaces = 2
    else
      gapSpaces = 1
    end
  end
  options.nontextlength = options.width - options.strLen - gapSpaces
  options.leftPadLen = math.floor(options.nontextlength / 2)
  options.rightPadLen = options.nontextlength - options.leftPadLen
  options.effWidth = options.width - ((options.capLen * gapSpaces) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end

  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end

  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing.
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne"
  -- "endcap================= some text"
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else
  --"=====endcap some text endcap====="
  --"=====endcap some text pacdne====="
  --"=================endcap some text"
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table")
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."

  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"

  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"

  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>--- Stand alone text formatter object. Remembers the options you set and can be adjusted as needed
-- @module demonnic.textFormatter
demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}

--- Set's the formatting type whether it's for cecho, decho, or hecho
--@tparam string typeToSet What type of formatter is this? Valid options are { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}
function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

--- Sets whether or not we should do word wrapping.
--@tparam boolean shouldWrap should we do wordwrapping?
function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

--- Sets the width we should format for
--@tparam number width the width we should format for
function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

--- Sets the cap for the formatter
--@tparam string cap the string to use for capping the formatted string.
function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

--- Sets the color for the format cap
--@tparam string capColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

--- Sets the color for spacing character
--@tparam string spacerColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

--- Sets the color for formatted text
--@tparam string textColor Color which can be formatted via Geyser.Color.parse()
function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

--- Sets the spacing character to use. Should be a single character
--@tparam string spacer the character to use for spacing
function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

--- Set the alignment to format for
--@tparam string alignment How to align the formatted string. Valid options are 'left', 'right', or 'center'
function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

--- Set whether the the spacer should go inside the the cap or outside of it
--@tparam boolean spacerInside 
function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

--- Set whether we should mirror/reverse the caps. IE &lt;&lt; becomes &gt;&gt; if set to true
--@tparam boolean shouldMirror
function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

--- Format a string based on the stored options
--@tparam string str The string to format
function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

--- Creates and returns a new TextFormatter. For valid options, please see https://github.com/demonnic/fText/wiki/fText
--@tparam table options the options for the text formatter to use when running format()
function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>--- Easy formatting for text tables
-- @module demonnic.TableMaker

demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",
  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
  autoEcho = false,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

--- Adds a column definition for the table. 
--@tparam table options Table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position The position of the column you're adding, counting from the left. If not provided will add it as the last column
function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

--- Deletes a column at the given position
--@tparam number position the column you wish to delete
function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

--- Replaces a column at a specific position with the newly provided formatting
--@tparam table options table of options suitable for a TextFormatter object. See https://github.com/demonnic/fText/wiki/fText
--@tparam number position which column you are replacing, counting from the left.
function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

--- Adds a row of output to the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down. If not provided defaults to the last line in the table.
function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

--- Deletes the row at the given position
--@tparam number position the row to delete
function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

--- Replaces a row of output in the table
--@tparam table columnEntries This indexed table contains an entry for each column in the table. Entries in the table must be strings, a table of options for insertPopup or insertLink, or a function which returns one of these things
--@tparam number position position for the row you want to add, counting from the top down.
function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  local allowedTypes = {
    "string"
  }
  if self.allowPopups then
    table.insert(allowedTypes, "table")
  end
  local entryType = type(entry)
  if entryType == "function" then
    entryType = type(entry())
  end
  if table.contains(allowedTypes, entryType) then
    return entry
  else
    return 0
  end
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

--- Sets a specific cell's display information
--@tparam number row the row number of the cell, counted from the top down
--@tparam number column the column number of the cell, counted from the left
--@param entry What to set the entry to. Must be a string, or a table of options for insertLink/insertPopup if allowPopups is set. Or a function which returns one of these things
function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:getType()
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, self.formatType) then
    return 'd'
  elseif table.contains(hex, self.formatType) then
    return 'h'
  elseif table.contains(col, self.formatType) then
    return 'c'
  else
    return ''
  end
end

function demonnic.TableMaker:echo(message, echoType, ...)
  local fType = self:getType()
  local consoleType = type(self.autoEchoConsole)
  local console = ""
  if echoType == nil then echoType = "" end
  if consoleType == "string" then
    console = self.autoEchoConsole
  else
    console = self.autoEchoConsole.name
  end
  local functionName = string.format("%secho%s", fType, echoType)
  local func = _G[functionName]
  if fType == "" then formatted = false end
  if echoType == "" then
    func(console, message)
  else
    func(console, message, ...)
  end
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:echoRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    if type(str) == "table" then 
      str = str[1]
    end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    self:echo(ec)
    for index,column in ipairs(columns) do
      local message = column[i]
      if index ~= 1 then 
        self:echo(sep)
      end
      if type(row[index]) == "string" then
        self:echo(message)
      elseif type(row[index]) == "table" then
        local rowEntry = row[index]
        local echoType = ""
        if type(rowEntry[2]) == "string" then
          echoType = "Link"
        elseif type(rowEntry[2]) == "table" then
          echoType = "Popup"
        end
        self:echo(message, echoType, rowEntry[2], rowEntry[3], rowEntry[4] or true)
      end
    end
    self:echo(ec)
    if i ~= linesInRow then
      self:echo("\n")
    end
  end
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

--- enables making cells which incorporate insertLink/insertPopup
function demonnic.TableMaker:enablePopups()
  self.autoEcho = true
  self.allowPopups = true
end

--- enables autoEcho so that when assemble is called it echos automatically
function demonnic.TableMaker:enableAutoEcho()
  self.autoEcho = true
end

--- disables autoecho. Cannot be used if allowPopups is set
function demonnic.TableMaker:disableAutoEcho()
  if self.allowPopups then
    error("demonnic.TableMaker:disableAutoEcho(): you cannot disable autoEcho once you have enabled popups.")
  else
    self.autoEcho = false
  end
end

--- Enables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:enableAutoClear()
  self.autoClear = true
end

--- Disables automatically clearing the miniconsole we echo to
function demonnic.TableMaker:disableAutoClear()
  self.autoClear = false
end

--- Set the miniconsole to echo to
--@param console The miniconsole to autoecho to. Set to "main" or do not pass the parameter to autoecho to the main console. Can be a string name of the console, or a Geyser MiniConsole
function demonnic.TableMaker:setAutoEchoConsole(console)
  local funcName = "demonnic.TableMaker:setAutoEchoConsole(console)"
  if console == nil then 
    console = "main" 
  end
  local consoleType = type(console)
  if consoleType ~= "string" and consoleType ~= "table" then
    error(funcName .. " ArgumentError: console as string or Geyser.MiniConsole expected, got " .. consoleType)
  elseif consoleType == "table" and console.type ~= "miniConsole" then
    error(funcName .. " ArgumentError: console received was a table and may be a Geyser object, but console.type is not miniConsole, it is " .. console.type)
  end
  self.autoEchoConsole = console
end

--- Assemble the table. If autoEcho is enabled/set to true, will automatically echo. Otherwise, returns the formatted string to echo the table
function demonnic.TableMaker:assemble()
  if self.allowPopups and self.autoEcho then
    self:popupAssemble()
  else
    return self:textAssemble()
  end
end

function demonnic.TableMaker:popupAssemble()
  if self.autoClear then
    local console = self.autoEchoConsole
    if console and console ~= "main" then
      if type(console) == "table" then
        console = console.name
      end
      clearWindow(console)
    end
  end
  local divWithNewLines = string.format("\n%s\n", self:createRowDivider())
  local header = self:makeHeader() .. "\n"
  local footer = string.format("\n%s%s%s\n", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  self:echo(header)
  for _,row in ipairs(self.rows) do
    if _ ~= 1 then
      self:echo(divWithNewLines)
    end
    self:echoRow(row)
  end
  self:echo(footer)
end

function demonnic.TableMaker:textAssemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s\n", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  if self.autoEcho then
    local console = self.autoEchoConsole or "main"
    if type(console) == "table" then console = console.name end
    if self.autoClear and console ~= "main" then
      clearWindow(console)
    end
    self:echo(sheet)
  end
  return sheet
end

--- Creates and returns a new TableMaker. See https://github.com/demonnic/fText/wiki/TableMaker for valid entries to the options table.
--@tparam table options table of options for the TableMaker object
function demonnic.TableMaker:new(options)
  local funcName = "emonnic.TableMaker:new(options)"
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  if options.allowPopups == true then
    options.autoEcho = true
  else
    options.allowPopups = false
  end
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>njs50pm.postInstallHandler</name>
			<packageName></packageName>
			<script>njs50pm.postInstallHandler = function(evt, name, file)

  -- after installing the package manager see if there is a package we should install
  if (name == "njs50-package-manager") then  
    if (postPMInstall) then      
      expandAlias('njs50pm install ' .. postPMInstall)
      postPMInstall = nil    
    end    
  end

end</script>
			<eventHandlerList>
				<string>sysInstallPackage</string>
			</eventHandlerList>
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
